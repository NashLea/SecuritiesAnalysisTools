import pandas as pd 
import numpy as np 
import yfinance as yf 

from .formatting import get_daterange

def download_data(config: dict) -> list:
    period = config['period']
    interval = config['interval']
    tickers = config['tickers']
    ticker_print = config['ticker print']

    if period is None:
        period = '2y'
    if interval is None:
        interval = '1d'
    
    daterange = get_daterange(period=period)
    
    if daterange[0] is None:
        print(f'Fetching data for {ticker_print} for {period} at {interval} intervals...')
        data = yf.download(tickers=tickers, period=period, interval=interval, group_by='ticker')
    else: 
        print(f'Fetching data for {ticker_print} from dates {daterange[0]} to {daterange[1]}...')
        data = yf.download(tickers=tickers, period=period, interval=interval, group_by='ticker', start=daterange[0], end=daterange[1])
    print(" ")

    return data


def data_nan_fix(data_df1: pd.DataFrame, fund_list=[]) -> pd.DataFrame:
    """ Data sent via provider sometimes has NaN in spots, which breaks many algorithms. This patches some of those glitches. """
    """ 'fund_list' is generated by fund_list_extractor and has already found the correct multi-level matches """
    """ Updates address 'SettingwithCopyWarning' on DataFrame """

    # Print out triggers and messages (help to understand better where these are coming from)
    # Messages only updated on 'Close' fields
    corrected = False
    status = []

    data_df = data_df1.copy()
    data_df = data_df.sort_index()
    # print(f"data_df: {data_df}")
    print(f"{data_df['VHT']['Close'][0]}")
    print(f"data1: {data_df.loc[data_df.index[0]]}")
    print(f"data2: {data_df.loc[data_df.index[0], 'VHT']}")
    print(f"data3: {data_df.loc[data_df.index[0], 'VHT']['Close']}")
    data_df.loc[data_df.index[0], 'VHT']['Close'] = 1234.56
    print(" ")
    print(f"data4: {data_df['VHT']['Close'][0]}")

    for fund in fund_list:

        if fund not in data_df.keys():
            # Single fund case (yfinance renders without multi-level key matches)

            close = list(np.where(pd.isna(data_df['Close']) == True))[0]
            adjclose = list(np.where(pd.isna(data_df['Adj Close']) == True))[0]
            vol = list(np.where(pd.isna(data_df['Volume']) == True))[0]
            op = list(np.where(pd.isna(data_df['Open']) == True))[0]
            high = list(np.where(pd.isna(data_df['High']) == True))[0]
            low = list(np.where(pd.isna(data_df['Low']) == True))[0]

            if len(close) > 0:
                corrected = True
                for e, cl in enumerate(close):
                    if (data_df['Close'].isna()[cl-1] == False) and (cl != 0) and (cl + 1 != len(data_df['Close'])) and (data_df['Close'].isna()[cl+1] == False):
                        status = add_status_message(status, 'Row-inner nan')
                        data_df.loc['Close', cl] = np.mean([data_df['Close'][cl-1], data_df['Close'][cl+1]])
                    elif (cl == 0) and (cl + 1 != len(data_df['Close'])) and (data_df['Close'].isna()[cl+1] == False):
                        status = add_status_message(status, 'Row-0 nan')
                        data_df.loc['Close', cl] = data_df['Close'][cl+1]
                    elif (cl == len(data_df['Close'])-1) and (data_df['Close'].isna()[cl-1] == False):
                        status = add_status_message(status, 'Mutual fund delay nan')
                        data_df.loc['Close', cl] = data_df['Close'][cl-1]
                    else:
                        status = add_status_message(status, 'Unknown/unfixable nan')
            if len(adjclose) > 0:
                corrected = True
                for e, cl in enumerate(adjclose):
                    if (data_df['Adj Close'].isna()[cl-1] == False) and (cl != 0) and (cl + 1 != len(data_df['Adj Close'])) and (data_df['Adj Close'].isna()[cl+1] == False):
                        data_df.loc['Adj Close', cl] = np.mean([data_df['Adj Adj Close'][cl-1], data_df['Adj Close'][cl+1]])
                    elif (cl == 0) and (cl + 1 != len(data_df['Adj Close'])) and (data_df['Adj Close'].isna()[cl+1] == False):
                        data_df.loc['Adj Close', cl] = data_df['Close'][cl+1]
                    elif (cl == len(data_df['Adj Close'])-1) and (data_df['Adj Close'].isna()[cl-1] == False):
                        data_df.loc['Adj Close', cl] = data_df['Adj Close'][cl-1]
            if len(vol) > 0:
                corrected = True
                for e, cl in enumerate(vol):
                    if (data_df['Volume'].isna()[cl-1] == False) and (cl != 0) and (cl + 1 != len(data_df['Volume'])) and (data_df['Volume'].isna()[cl+1] == False):
                        data_df.loc['Volume', cl] = np.mean([data_df['Volume'][cl-1], data_df['Volume'][cl+1]])
                    elif (cl == 0) and (cl + 1 != len(data_df['Volume'])) and (data_df['Volume'].isna()[cl+1] == False):
                        data_df.loc['Volume', cl] = data_df['Volume'][cl+1]
                    elif (cl == len(data_df['Volume'])-1) and (data_df['Volume'].isna()[cl-1] == False):
                        data_df.loc['Volume', cl] = data_df['Volume'][cl-1]
            if len(op) > 0:
                corrected = True
                for e, cl in enumerate(op):
                    if (data_df['Open'].isna()[cl-1] == False) and (cl != 0) and (cl + 1 != len(data_df['Open'])) and (data_df['Open'].isna()[cl+1] == False):
                        data_df.loc['Open', cl] = np.mean([data_df['Open'][cl-1], data_df['Open'][cl+1]])
                    elif (cl == 0) and (cl + 1 != len(data_df['Open'])) and (data_df['Open'].isna()[cl+1] == False):
                        data_df.loc['Open', cl] = data_df['Open'][cl+1]
                    elif (cl == len(data_df['Open'])-1) and (data_df['Open'].isna()[cl-1] == False):
                        data_df.loc['Open', cl] = data_df['Open'][cl-1]
            if len(high) > 0:
                corrected = True
                for e, cl in enumerate(high):
                    if (data_df['High'].isna()[cl-1] == False) and (cl != 0) and (cl + 1 != len(data_df['High'])) and (data_df['High'].isna()[cl+1] == False):
                        data_df.loc['High', cl] = np.mean([data_df['High'][cl-1], data_df['High'][cl+1]])
                    elif (cl == 0) and (cl + 1 != len(data_df['High'])) and (data_df['High'].isna()[cl+1] == False):
                        data_df.loc['High', cl] = data_df['High'][cl+1]
                    elif (cl == len(data_df['High'])-1) and (data_df['High'].isna()[cl-1] == False):
                        data_df.loc['High', cl] = data_df['High'][cl-1]
            if len(low) > 0:
                corrected = True
                for e, cl in enumerate(low):
                    if (data_df['Low'].isna()[cl-1] == False) and (cl != 0) and (cl + 1 != len(data_df['Low'])) and (data_df['Low'].isna()[cl+1] == False):
                        data_df.loc['Low', cl] = np.mean([data_df['Low'][cl-1], data_df['Low'][cl+1]])
                    elif (cl == 0) and (cl + 1 != len(data_df['Low'])) and (data_df['Low'].isna()[cl+1] == False):
                        data_df.loc['Low', cl] = data_df['Low'][cl+1]
                    elif (cl == len(data_df['Low'])-1) and (data_df['Low'].isna()[cl-1] == False):
                        data_df.loc['Low', cl] = data_df['Low'][cl-1]

            if corrected:
                print(f"Note: 'NaN' found on {fund} data. (Type: {get_status_message(status)}): Corrected OK.")
                corrected = False
                status = []


        else:
            close = list(np.where(pd.isna(data_df[fund]['Close']) == True))[0]
            adjclose = list(np.where(pd.isna(data_df[fund]['Adj Close']) == True))[0]
            vol = list(np.where(pd.isna(data_df[fund]['Volume']) == True))[0]
            op = list(np.where(pd.isna(data_df[fund]['Open']) == True))[0]
            high = list(np.where(pd.isna(data_df[fund]['High']) == True))[0]
            low = list(np.where(pd.isna(data_df[fund]['Low']) == True))[0]

            if len(close) > 0:
                corrected = True
                for e, cl in enumerate(close):
                    if (data_df[fund]['Close'].isna()[cl-1] == False) and (cl != 0) and (cl + 1 != len(data_df[fund]['Close'])) and (data_df[fund]['Close'].isna()[cl+1] == False):
                        status = add_status_message(status, 'Row-inner nan')
                        data_df[fund].loc['Close', cl] = np.mean([data_df[fund]['Close'][cl-1], data_df[fund]['Close'][cl+1]])
                    elif (cl == 0) and (cl + 1 != len(data_df[fund]['Close'])) and (data_df[fund]['Close'].isna()[cl+1] == False):
                        status = add_status_message(status, 'Row-0 nan')
                        data_df[fund].loc['Close', cl] = data_df[fund]['Close'][cl+1]
                    elif (cl == len(data_df[fund]['Close'])-1) and (data_df[fund]['Close'].isna()[cl-1] == False):
                        status = add_status_message(status, 'Mutual fund delay nan')
                        # data_df[fund].loc['Close', cl] = data_df[fund]['Close'][cl-1]
                        print("close?")
                        data_df.loc[data_df.index[cl], fund, 'Close'] = data_df[fund]['Close'][cl-1]
                        print("~close~")
                    else:
                        status = add_status_message(status, 'Unknown/unfixable nan')
            if len(adjclose) > 0:
                corrected = True
                for e, cl in enumerate(adjclose):
                    if (data_df[fund]['Adj Close'].isna()[cl-1] == False) and (cl != 0) and (cl + 1 != len(data_df[fund]['Adj Close'])) and (data_df[fund]['Adj Close'].isna()[cl+1] == False):
                        data_df[fund].loc['Adj Close', cl] = np.mean([data_df[fund]['Adj Close'][cl-1], data_df[fund]['Adj Close'][cl+1]])
                    elif (cl == 0) and (cl + 1 != len(data_df[fund]['Adj Close'])) and (data_df[fund]['Adj Close'].isna()[cl+1] == False):
                        data_df[fund].loc['Adj Close', cl] = data_df[fund]['Adj Close'][cl+1]
                    elif (cl == len(data_df[fund]['Adj Close'])-1) and (data_df[fund]['Adj Close'].isna()[cl-1] == False):
                        data_df[fund].loc['Adj Close', cl] = data_df[fund]['Adj Close'][cl-1]
            if len(vol) > 0:
                corrected = True
                for e, cl in enumerate(vol):
                    if (data_df[fund]['Volume'].isna()[cl-1] == False) and (cl != 0) and (cl + 1 != len(data_df[fund]['Volume'])) and (data_df[fund]['Volume'].isna()[cl+1] == False):
                        data_df[fund].loc['Volume', cl] = np.mean([data_df[fund]['Volume'][cl-1], data_df[fund]['Volume'][cl+1]])
                    elif (cl == 0) and (cl + 1 != len(data_df[fund]['Volume'])) and (data_df[fund]['Volume'].isna()[cl+1] == False):
                        data_df[fund].loc['Volume', cl] = data_df[fund]['Volume'][cl+1]
                    elif (cl == len(data_df[fund]['Volume'])-1) and (data_df[fund]['Volume'].isna()[cl-1] == False):
                        data_df[fund].loc['Volume', cl] = data_df[fund]['Volume'][cl-1]
            if len(op) > 0:
                corrected = True
                for e, cl in enumerate(op):
                    if (data_df[fund]['Open'].isna()[cl-1] == False) and (cl != 0) and (cl + 1 != len(data_df[fund]['Open'])) and (data_df[fund]['Open'].isna()[cl+1] == False):
                        data_df[fund].loc['Open', cl] = np.mean([data_df[fund]['Open'][cl-1], data_df[fund]['Open'][cl+1]])
                    elif (cl == 0) and (cl + 1 != len(data_df[fund]['Open'])) and (data_df[fund]['Open'].isna()[cl+1] == False):
                        data_df[fund].loc['Open', cl] = data_df[fund]['Open'][cl+1]
                    elif (cl == len(data_df[fund]['Open'])-1) and (data_df[fund]['Open'].isna()[cl-1] == False):
                        data_df[fund].loc['Open', cl] = data_df[fund]['Open'][cl-1]
            if len(high) > 0:
                corrected = True
                for e, cl in enumerate(high):
                    if (data_df[fund]['High'].isna()[cl-1] == False) and (cl != 0) and (cl + 1 != len(data_df[fund]['High'])) and (data_df[fund]['High'].isna()[cl+1] == False):
                        data_df[fund].loc['High', cl] = np.mean([data_df[fund]['High'][cl-1], data_df[fund]['High'][cl+1]])
                    elif (cl == 0) and (cl + 1 != len(data_df[fund]['High'])) and (data_df[fund]['High'].isna()[cl+1] == False):
                        data_df[fund].loc['High', cl] = data_df[fund]['High'][cl+1]
                    elif (cl == len(data_df[fund]['High'])-1) and (data_df[fund]['High'].isna()[cl-1] == False):
                        data_df[fund].loc['High', cl] = data_df[fund]['High'][cl-1]
            if len(low) > 0:
                corrected = True
                for e, cl in enumerate(low):
                    if (data_df[fund]['Low'].isna()[cl-1] == False) and (cl != 0) and (cl + 1 != len(data_df[fund]['Low'])) and (data_df[fund]['Low'].isna()[cl+1] == False):
                        data_df[fund].loc['Low', cl] = np.mean([data_df[fund]['Low'][cl-1], data_df[fund]['Low'][cl+1]])
                    elif (cl == 0) and (cl + 1 != len(data_df[fund]['Low'])) and (data_df[fund]['Low'].isna()[cl+1] == False):
                        data_df[fund].loc['Low', cl] = data_df[fund]['Low'][cl+1]
                    elif (cl == len(data_df[fund]['Low'])-1) and (data_df[fund]['Low'].isna()[cl-1] == False):
                        data_df[fund].loc['Low', cl] = data_df[fund]['Low'][cl-1]

            if corrected:
                print(f"Note: 'NaN' found on {fund} data. (Type: {get_status_message(status)}): Corrected OK.")
                corrected = False
                status = []


    return data_df



def add_status_message(status: list, new_message: str) -> str:
    """ adds 'new_message' to status if it isn't added already """
    need_to_add = True
    for i, message in enumerate(status):
        if new_message == message['message']:
            status[i]['count'] += 1
            need_to_add = False
    if need_to_add:
        status.append({'message': new_message, 'count': 1})
    return status


def get_status_message(status: list) -> str:
    message = ''
    for i,item in enumerate(status):
        message += f"{item['message']} ({item['count']})"
        if i < len(status)-1:
            message += ', '
    return message