import pandas as pd 
import numpy as np 
import math
import yfinance as yf 

from .formatting import get_daterange, fund_list_extractor


def download_data_indexes(indexes: list, tickers: str, period: str='2y', interval='1d') -> list:
    data = yf.download(tickers=tickers, period=period, interval='1d', group_by='ticker')
    data = data_format(data, config=None, list_of_funds=indexes)
    return data, indexes


def download_data(config: dict) -> list:
    period = config['period']
    interval = config['interval']
    tickers = config['tickers']
    ticker_print = config['ticker print']

    if period is None:
        period = '2y'
    if interval is None:
        interval = '1d'
    
    daterange = get_daterange(period=period)
    
    if daterange[0] is None:
        print(f'Fetching data for {ticker_print} for {period} at {interval} intervals...')
        data = yf.download(tickers=tickers, period=period, interval=interval, group_by='ticker')
    else: 
        print(f'Fetching data for {ticker_print} from dates {daterange[0]} to {daterange[1]}...')
        data = yf.download(tickers=tickers, period=period, interval=interval, group_by='ticker', start=daterange[0], end=daterange[1])
    print(" ")

    funds = fund_list_extractor(data, config=config)
    data = data_format(data, config=config)

    print(f"funds: {funds}")

    return data, funds


def data_nan_fix(data_df1: pd.DataFrame, fund_list=[]) -> pd.DataFrame:
    """ Data sent via provider sometimes has NaN in spots, which breaks many algorithms. This patches some of those glitches. """
    """ 'fund_list' is generated by fund_list_extractor and has already found the correct multi-level matches """
    """ Updates address 'SettingwithCopyWarning' on DataFrame """

    # Print out triggers and messages (help to understand better where these are coming from)
    # Messages only updated on 'Close' fields
    corrected = False
    status = []

    data_df = data_df1.copy()
    data_df = data_df.sort_index()
    # print(f"data_df: {data_df}")
    print(f"{data_df['VHT']['Close'][0]}")
    print(f"data1: {data_df.loc[data_df.index[0]]}")
    print(f"data2: {data_df.loc[data_df.index[0], 'VHT']}")
    print(f"data3: {data_df.loc[data_df.index[0], 'VHT']['Close']}")
    data_df.loc[data_df.index[0], 'VHT']['Close'] = 1234.56
    print(" ")
    print(f"data4: {data_df['VHT']['Close'][0]}")

    for fund in fund_list:

        if fund not in data_df.keys():
            # Single fund case (yfinance renders without multi-level key matches)

            close = list(np.where(pd.isna(data_df['Close']) == True))[0]
            adjclose = list(np.where(pd.isna(data_df['Adj Close']) == True))[0]
            vol = list(np.where(pd.isna(data_df['Volume']) == True))[0]
            op = list(np.where(pd.isna(data_df['Open']) == True))[0]
            high = list(np.where(pd.isna(data_df['High']) == True))[0]
            low = list(np.where(pd.isna(data_df['Low']) == True))[0]

            if len(close) > 0:
                corrected = True
                for e, cl in enumerate(close):
                    if (data_df['Close'].isna()[cl-1] == False) and (cl != 0) and (cl + 1 != len(data_df['Close'])) and (data_df['Close'].isna()[cl+1] == False):
                        status = add_status_message(status, 'Row-inner nan')
                        data_df.loc['Close', cl] = np.mean([data_df['Close'][cl-1], data_df['Close'][cl+1]])
                    elif (cl == 0) and (cl + 1 != len(data_df['Close'])) and (data_df['Close'].isna()[cl+1] == False):
                        status = add_status_message(status, 'Row-0 nan')
                        data_df.loc['Close', cl] = data_df['Close'][cl+1]
                    elif (cl == len(data_df['Close'])-1) and (data_df['Close'].isna()[cl-1] == False):
                        status = add_status_message(status, 'Mutual fund delay nan')
                        data_df.loc['Close', cl] = data_df['Close'][cl-1]
                    else:
                        status = add_status_message(status, 'Unknown/unfixable nan')
            if len(adjclose) > 0:
                corrected = True
                for e, cl in enumerate(adjclose):
                    if (data_df['Adj Close'].isna()[cl-1] == False) and (cl != 0) and (cl + 1 != len(data_df['Adj Close'])) and (data_df['Adj Close'].isna()[cl+1] == False):
                        data_df.loc['Adj Close', cl] = np.mean([data_df['Adj Adj Close'][cl-1], data_df['Adj Close'][cl+1]])
                    elif (cl == 0) and (cl + 1 != len(data_df['Adj Close'])) and (data_df['Adj Close'].isna()[cl+1] == False):
                        data_df.loc['Adj Close', cl] = data_df['Close'][cl+1]
                    elif (cl == len(data_df['Adj Close'])-1) and (data_df['Adj Close'].isna()[cl-1] == False):
                        data_df.loc['Adj Close', cl] = data_df['Adj Close'][cl-1]
            if len(vol) > 0:
                corrected = True
                for e, cl in enumerate(vol):
                    if (data_df['Volume'].isna()[cl-1] == False) and (cl != 0) and (cl + 1 != len(data_df['Volume'])) and (data_df['Volume'].isna()[cl+1] == False):
                        data_df.loc['Volume', cl] = np.mean([data_df['Volume'][cl-1], data_df['Volume'][cl+1]])
                    elif (cl == 0) and (cl + 1 != len(data_df['Volume'])) and (data_df['Volume'].isna()[cl+1] == False):
                        data_df.loc['Volume', cl] = data_df['Volume'][cl+1]
                    elif (cl == len(data_df['Volume'])-1) and (data_df['Volume'].isna()[cl-1] == False):
                        data_df.loc['Volume', cl] = data_df['Volume'][cl-1]
            if len(op) > 0:
                corrected = True
                for e, cl in enumerate(op):
                    if (data_df['Open'].isna()[cl-1] == False) and (cl != 0) and (cl + 1 != len(data_df['Open'])) and (data_df['Open'].isna()[cl+1] == False):
                        data_df.loc['Open', cl] = np.mean([data_df['Open'][cl-1], data_df['Open'][cl+1]])
                    elif (cl == 0) and (cl + 1 != len(data_df['Open'])) and (data_df['Open'].isna()[cl+1] == False):
                        data_df.loc['Open', cl] = data_df['Open'][cl+1]
                    elif (cl == len(data_df['Open'])-1) and (data_df['Open'].isna()[cl-1] == False):
                        data_df.loc['Open', cl] = data_df['Open'][cl-1]
            if len(high) > 0:
                corrected = True
                for e, cl in enumerate(high):
                    if (data_df['High'].isna()[cl-1] == False) and (cl != 0) and (cl + 1 != len(data_df['High'])) and (data_df['High'].isna()[cl+1] == False):
                        data_df.loc['High', cl] = np.mean([data_df['High'][cl-1], data_df['High'][cl+1]])
                    elif (cl == 0) and (cl + 1 != len(data_df['High'])) and (data_df['High'].isna()[cl+1] == False):
                        data_df.loc['High', cl] = data_df['High'][cl+1]
                    elif (cl == len(data_df['High'])-1) and (data_df['High'].isna()[cl-1] == False):
                        data_df.loc['High', cl] = data_df['High'][cl-1]
            if len(low) > 0:
                corrected = True
                for e, cl in enumerate(low):
                    if (data_df['Low'].isna()[cl-1] == False) and (cl != 0) and (cl + 1 != len(data_df['Low'])) and (data_df['Low'].isna()[cl+1] == False):
                        data_df.loc['Low', cl] = np.mean([data_df['Low'][cl-1], data_df['Low'][cl+1]])
                    elif (cl == 0) and (cl + 1 != len(data_df['Low'])) and (data_df['Low'].isna()[cl+1] == False):
                        data_df.loc['Low', cl] = data_df['Low'][cl+1]
                    elif (cl == len(data_df['Low'])-1) and (data_df['Low'].isna()[cl-1] == False):
                        data_df.loc['Low', cl] = data_df['Low'][cl-1]

            if corrected:
                print(f"Note: 'NaN' found on {fund} data. (Type: {get_status_message(status)}): Corrected OK.")
                corrected = False
                status = []


        else:
            close = list(np.where(pd.isna(data_df[fund]['Close']) == True))[0]
            adjclose = list(np.where(pd.isna(data_df[fund]['Adj Close']) == True))[0]
            vol = list(np.where(pd.isna(data_df[fund]['Volume']) == True))[0]
            op = list(np.where(pd.isna(data_df[fund]['Open']) == True))[0]
            high = list(np.where(pd.isna(data_df[fund]['High']) == True))[0]
            low = list(np.where(pd.isna(data_df[fund]['Low']) == True))[0]

            if len(close) > 0:
                corrected = True
                for e, cl in enumerate(close):
                    if (data_df[fund]['Close'].isna()[cl-1] == False) and (cl != 0) and (cl + 1 != len(data_df[fund]['Close'])) and (data_df[fund]['Close'].isna()[cl+1] == False):
                        status = add_status_message(status, 'Row-inner nan')
                        data_df[fund].loc['Close', cl] = np.mean([data_df[fund]['Close'][cl-1], data_df[fund]['Close'][cl+1]])
                    elif (cl == 0) and (cl + 1 != len(data_df[fund]['Close'])) and (data_df[fund]['Close'].isna()[cl+1] == False):
                        status = add_status_message(status, 'Row-0 nan')
                        data_df[fund].loc['Close', cl] = data_df[fund]['Close'][cl+1]
                    elif (cl == len(data_df[fund]['Close'])-1) and (data_df[fund]['Close'].isna()[cl-1] == False):
                        status = add_status_message(status, 'Mutual fund delay nan')
                        # data_df[fund].loc['Close', cl] = data_df[fund]['Close'][cl-1]
                        print("close?")
                        data_df.loc[data_df.index[cl], fund, 'Close'] = data_df[fund]['Close'][cl-1]
                        print("~close~")
                    else:
                        status = add_status_message(status, 'Unknown/unfixable nan')
            if len(adjclose) > 0:
                corrected = True
                for e, cl in enumerate(adjclose):
                    if (data_df[fund]['Adj Close'].isna()[cl-1] == False) and (cl != 0) and (cl + 1 != len(data_df[fund]['Adj Close'])) and (data_df[fund]['Adj Close'].isna()[cl+1] == False):
                        data_df[fund].loc['Adj Close', cl] = np.mean([data_df[fund]['Adj Close'][cl-1], data_df[fund]['Adj Close'][cl+1]])
                    elif (cl == 0) and (cl + 1 != len(data_df[fund]['Adj Close'])) and (data_df[fund]['Adj Close'].isna()[cl+1] == False):
                        data_df[fund].loc['Adj Close', cl] = data_df[fund]['Adj Close'][cl+1]
                    elif (cl == len(data_df[fund]['Adj Close'])-1) and (data_df[fund]['Adj Close'].isna()[cl-1] == False):
                        data_df[fund].loc['Adj Close', cl] = data_df[fund]['Adj Close'][cl-1]
            if len(vol) > 0:
                corrected = True
                for e, cl in enumerate(vol):
                    if (data_df[fund]['Volume'].isna()[cl-1] == False) and (cl != 0) and (cl + 1 != len(data_df[fund]['Volume'])) and (data_df[fund]['Volume'].isna()[cl+1] == False):
                        data_df[fund].loc['Volume', cl] = np.mean([data_df[fund]['Volume'][cl-1], data_df[fund]['Volume'][cl+1]])
                    elif (cl == 0) and (cl + 1 != len(data_df[fund]['Volume'])) and (data_df[fund]['Volume'].isna()[cl+1] == False):
                        data_df[fund].loc['Volume', cl] = data_df[fund]['Volume'][cl+1]
                    elif (cl == len(data_df[fund]['Volume'])-1) and (data_df[fund]['Volume'].isna()[cl-1] == False):
                        data_df[fund].loc['Volume', cl] = data_df[fund]['Volume'][cl-1]
            if len(op) > 0:
                corrected = True
                for e, cl in enumerate(op):
                    if (data_df[fund]['Open'].isna()[cl-1] == False) and (cl != 0) and (cl + 1 != len(data_df[fund]['Open'])) and (data_df[fund]['Open'].isna()[cl+1] == False):
                        data_df[fund].loc['Open', cl] = np.mean([data_df[fund]['Open'][cl-1], data_df[fund]['Open'][cl+1]])
                    elif (cl == 0) and (cl + 1 != len(data_df[fund]['Open'])) and (data_df[fund]['Open'].isna()[cl+1] == False):
                        data_df[fund].loc['Open', cl] = data_df[fund]['Open'][cl+1]
                    elif (cl == len(data_df[fund]['Open'])-1) and (data_df[fund]['Open'].isna()[cl-1] == False):
                        data_df[fund].loc['Open', cl] = data_df[fund]['Open'][cl-1]
            if len(high) > 0:
                corrected = True
                for e, cl in enumerate(high):
                    if (data_df[fund]['High'].isna()[cl-1] == False) and (cl != 0) and (cl + 1 != len(data_df[fund]['High'])) and (data_df[fund]['High'].isna()[cl+1] == False):
                        data_df[fund].loc['High', cl] = np.mean([data_df[fund]['High'][cl-1], data_df[fund]['High'][cl+1]])
                    elif (cl == 0) and (cl + 1 != len(data_df[fund]['High'])) and (data_df[fund]['High'].isna()[cl+1] == False):
                        data_df[fund].loc['High', cl] = data_df[fund]['High'][cl+1]
                    elif (cl == len(data_df[fund]['High'])-1) and (data_df[fund]['High'].isna()[cl-1] == False):
                        data_df[fund].loc['High', cl] = data_df[fund]['High'][cl-1]
            if len(low) > 0:
                corrected = True
                for e, cl in enumerate(low):
                    if (data_df[fund]['Low'].isna()[cl-1] == False) and (cl != 0) and (cl + 1 != len(data_df[fund]['Low'])) and (data_df[fund]['Low'].isna()[cl+1] == False):
                        data_df[fund].loc['Low', cl] = np.mean([data_df[fund]['Low'][cl-1], data_df[fund]['Low'][cl+1]])
                    elif (cl == 0) and (cl + 1 != len(data_df[fund]['Low'])) and (data_df[fund]['Low'].isna()[cl+1] == False):
                        data_df[fund].loc['Low', cl] = data_df[fund]['Low'][cl+1]
                    elif (cl == len(data_df[fund]['Low'])-1) and (data_df[fund]['Low'].isna()[cl-1] == False):
                        data_df[fund].loc['Low', cl] = data_df[fund]['Low'][cl-1]

            if corrected:
                print(f"Note: 'NaN' found on {fund} data. (Type: {get_status_message(status)}): Corrected OK.")
                corrected = False
                status = []


    return data_df



def add_status_message(status: list, new_message: str) -> str:
    """ adds 'new_message' to status if it isn't added already """
    need_to_add = True
    for i, message in enumerate(status):
        if new_message == message['message']:
            status[i]['count'] += 1
            need_to_add = False
    if need_to_add:
        status.append({'message': new_message, 'count': 1})
    return status


def get_status_message(status: list) -> str:
    message = ''
    for i,item in enumerate(status):
        message += f"{item['message']} ({item['count']})"
        if i < len(status)-1:
            message += ', '
    return message



def data_format(data: pd.DataFrame, config: dict, list_of_funds=None) -> dict:
    data_dict = {}
    fund_keys = list_of_funds
    if list_of_funds is None:
        fund_keys = fund_list_extractor(data, config=config)
    dates = data.index 

    if 'Open' in data.keys():
        # Singular fund case
        df_dict = {}
        df_dict['Date'] = dates.copy() 
        df_dict['Open'] = filter_nan(data['Open'].copy(), fund_name=fund_keys[0])
        df_dict['Close'] = filter_nan(data['Close'].copy())
        df_dict['High'] = filter_nan(data['High'].copy())
        df_dict['Low'] = filter_nan(data['Low'].copy())
        df_dict['Adj Close'] = filter_nan(data['Adj Close'].copy())
        df_dict['Volume'] = filter_nan(data['Volume'].copy())

        df = pd.DataFrame.from_dict(df_dict)
        df = df.set_index('Date')

        data_dict[fund_keys[0]] = df.copy()

    else:
        for fund in fund_keys:
            df_dict = {}
            df_dict['Date'] = dates.copy() 
            df_dict['Open'] = filter_nan(data[fund]['Open'].copy(), fund_name=fund)
            df_dict['Close'] = filter_nan(data[fund]['Close'].copy())
            df_dict['High'] = filter_nan(data[fund]['High'].copy())
            df_dict['Low'] = filter_nan(data[fund]['Low'].copy())
            df_dict['Adj Close'] = filter_nan(data[fund]['Adj Close'].copy())
            df_dict['Volume'] = filter_nan(data[fund]['Volume'].copy())

            df = pd.DataFrame.from_dict(df_dict)
            df = df.set_index('Date')

            data_dict[fund] = df.copy()

    return data_dict


def filter_nan(frame_list: pd.DataFrame, fund_name=None) -> list:
    new_list = list(frame_list.copy())
    nans = list(np.where(pd.isna(frame_list) == True))[0]

    corrected = False
    status = []

    if len(nans) > 0:
        corrected = True
        for na in nans:
            if (na == 0) and (not math.isnan(new_list[na+1])):
                status = add_status_message(status, 'Row-0 nan')
                new_list[na] = new_list[na+1]
            elif (na != 0) and (na != len(new_list)-1) and (not math.isnan(new_list[na-1]) and (not math.isnan(new_list[na+1]))):
                status = add_status_message(status, 'Row-inner nan')
                new_list[na] = np.round(np.mean([new_list[na-1], new_list[na+1]]), 2)
            elif (na == len(new_list)-1) and (not math.isnan(new_list[na-1])):
                status = add_status_message(status, 'Mutual Fund nan')
                new_list[na] = new_list[na-1]
            else:
                status = add_status_message(status, 'Unknown/unfixable nan')

    if corrected and (fund_name is not None):
        print(f"Note: 'NaN' found on {fund_name} data. Type: '{get_status_message(status)}': Corrected OK.")
        
    return new_list
